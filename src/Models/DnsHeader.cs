using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;

// <summary>
// [1] http://www.tcpipguide.com/free/t_DNSMessageHeaderandQuestionSectionFormat.htm
// </summary>

namespace HMNT.SimpDNS
{
    public class DnsHeader
    {
        // Generated by the device that creates the DNS query
        public ushort TransactionID;

        /* Theres multiple flags within these 16 bits
        * 1.[QR] Query/Response - 1 bit
        * 2.[OpCode] Operation Code - 6 bits - REFER TO [1]
        * 3.[AA] Authoritative Answer - 1 bit - if resp is coming from an authoritative server
        * 4.[TC] Truncation - 1 bit
        * 5.[RD] Recursion Desired - 1 bit
        * 6.[RA] Recursion Available - 1 bit - if responding server supports recursive queries
        * 7.[Z] Reserved bits - 3 bits
        * 8.[RCode] Response Code - 4 bits - REFER TO [1]
        */
        public ushort Flags;

        // Number of questions in the question section
        public ushort QuestionCount;

        // Number of resource records in the Answer section
        public ushort AnswerRecordCount;

        // Number of resource records in Authority Section
        public ushort AuthorityCount;

        // Number of resource records in Additional Section
        public ushort AdditionalRecordCount;


        // Helper functions
        public bool IsQuery() { return (Flags & Dns.FlagQR) == 0; }
        public bool IsAuthoritative() { return (Flags & Dns.FlagAA) != 0; }
        public bool IsTruncated() { return (Flags & Dns.FlagTC) != 0; }
        public bool IsRecursionDesired() { return (Flags & Dns.FlagRD) != 0; }
        public bool IsRecursionAvailable() { return (Flags & Dns.FlagRA) != 0; }

        public int GetOpCode() { return (Flags >> 11) & 0x0F; }
        public void SetOpCode(int opCode) { Flags = (ushort)ModifyFlagsBinary(Flags, 11, 15, opCode); }

        public int GetResponseCode() { return Flags & 0x0F; }
        public void SetResponseCode(int rCode) { Flags = (ushort)ModifyFlagsBinary(Flags, 0, 3, rCode); }
        
        private static string GetOpCodeString(int opcode)
        {
            switch (opcode)
            {
                case 0: return "QUERY";
                case 1: return "IQUERY";
                case 2: return "STATUS";
                default: return $"OPCODE{opcode}";
            }
        }

        private static string GetResponseCodeString(int rcode)
        {
            switch (rcode)
            {
                case 0: return "NOERROR";
                case 1: return "FORMERR";
                case 2: return "SERVFAIL";
                case 3: return "NXDOMAIN";
                case 4: return "NOTIMP";
                case 5: return "REFUSED";
                default: return $"RCODE{rcode}";
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            
            sb.AppendLine($"id {TransactionID}");
            sb.AppendLine($"opcode {GetOpCodeString(GetOpCode())}");
            sb.AppendLine($"rcode {GetResponseCodeString(GetResponseCode())}");
            
            List<string> flags = new List<string>();
            if (!IsQuery()) flags.Add("QR");
            if (IsAuthoritative()) flags.Add("AA");
            if (IsTruncated()) flags.Add("TC");
            if (IsRecursionDesired()) flags.Add("RD");
            if (IsRecursionAvailable()) flags.Add("RA");
            sb.AppendLine($"flags {string.Join(" ", flags)}");

            return sb.ToString();
        }

        // Both these methods support big-endian indices cuz of network byte order
        // Theres definitely a more efficient way to do this 
        public static ushort ModifyFlagsBinary(ushort flags, int startIdx, int endIdx, int value)
        {
            // Set a particular range of bits to a particular binary value
            int rangeLength = endIdx - startIdx + 1;
            
            string originalFlags = Convert.ToString(flags, 2);
            originalFlags = originalFlags.PadLeft(16, '0'); // ensure 16 bits
            
            string binaryValue = Convert.ToString(value, 2);
            binaryValue = binaryValue.PadLeft(rangeLength, '0'); // ensure range length
            binaryValue = binaryValue.Substring(binaryValue.Length - rangeLength); // truncate if too long
       
            
            char[] newFlags = originalFlags.ToCharArray();

            int valueIndex = 0;
            for (int i = startIdx; i <= endIdx; i++)
            {
                newFlags[15 - i] = binaryValue[valueIndex++];
            }
            
            return Convert.ToUInt16(new string(newFlags), 2);
        }
    }
}